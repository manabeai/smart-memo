=begin
SmartMemo API

SmartMemoのAPI仕様書

The version of the OpenAPI document: 1.0.0
Generated by: https://github.com/openapitools/openapi-generator.git

=end
require 'net/http'
require 'json'
require 'uri'
require "set"

class MemosController < ApplicationController
  def create_memo
    @memo = Memo.create(title: params[:title], content: params[:content], user_id: @user_id)

    params[:tags].each do |tag|
      unless tag[:is_user_defined].nil?
        Tagging.create(memo_id: @memo.id, tag_id: tag[:is_user_defined])
      else
        @tag = Tag.create(name: tag[:name], user_id: @user_id)
        Tagging.create(memo_id: @memo.id, tag_id: @tag.id)
      end
    end

    render json: @memo.as_json(include: { tags: { only: [ :id, :name ] } })
  end

  def destroy
    Memo.find(params[:id]).destroy
    # Your code here

    render json: { "message" => "yes, it worked" }, status: 204
  end

  def show
    # Your code here
    @memo = Memo.find(params[:id])

    render json: @memo.as_json(include: { tags: { only: [ :id, :name ] } })
  end

  def index
    @memos = User.find(@user_id).memos.includes(:tags).order(updated_at: :desc)

    render json: @memos.as_json(include: { tags: { only: [ :id, :name ] } })
  end

  def create
    url = URI.parse('https://api.openai.com/v1/chat/completions')
    title = params[:title]
    content = params[:content]
    tags_list = Tag.where(user_id: @user_id).pluck(:id, :name).map { |id, name| { id: id, name: name } }
    tags_list_to_message = tags_list.map { |hash| "[#{hash[:id]}, #{hash[:name]}]" }.join(', ')
    data = {
      model: "gpt-4o-2024-08-06",
      messages: [
        {
          role: "system",
          content: "あなたは非常に優秀なメモアプリのタグを提案するプロですユーザーはメモに書いた内容と彼が作ったタグ一覧をあなたに提示します。あなたの仕事は、ユーザーが既に作ったタグの中からメモの内容にふさわしいものを選び3つから6つ配列で提案することです。もし、あなたが提示するタグがユーザーが作ったタグの中に既にあるものであればis_user_definedをそのIDに、あなたが考えたものであればnullとしてください。最低でも一つはあなた自身が考えた新しいタグを解答に含めてください。ユーザーの作成したタグの中にふさわしいものがない場合、全てあなたの提案するタグでも構いません。"
        },
        {
          role: "user",
          content: "メモのタイトル #{params[:title]} メモの内容: #{params[:content]} タグ一覧 #{tags_list_to_message}"
        }
      ],
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "ttt",
          schema: {
            type: "object",
            properties: {
              tags: {
                type: "array",
                description: "An array of objects each containing an is_user_defined and a name.",
                items: {
                  type: "object",
                  properties: {
                    is_user_defined: {
                      type: "integer",
                      description: "もし最初与えたリストの中に含まれていたのであればそのid、そうでなければnull"
                    },
                    name: {
                      type: "string",
                      description: "コンテンツの内容に沿ったタグ"
                    }
                  },
                  required: ["name", "is_user_defined"],
                  additionalProperties: false
                },
                strict: true
              }
            }
          }
        }
      }
    }
    http = Net::HTTP.new(url.host, url.port)
    http.use_ssl = true
    request = Net::HTTP::Post.new(url.path, {
      'Content-Type' => 'application/json',
      'Authorization' => "Bearer #{Rails.application.credentials[:OPENAI_KEY] || ENV["OPENAI_KEY"]}"
    })
    request.body = data.to_json
    response = http.request(request)

    tags =  JSON.parse(JSON.parse(response.body)["choices"][0]["message"]["content"])["tags"]
    Rails.logger.info(tags)

    render json: {
      title: "sample_title",
      content: "sample_content",
      tags: tags
    }
  end

  def update
    @memo = Memo.find(params[:id])
    @updated_tag_ids = Set.new(params[:tags].map { |tag| tag[:id] }.compact)
    @taggings = Memo.find(params[:id]).taggings

    @taggings.each do |tagging|
      unless @updated_tag_ids.include?(tagging.tag_id)
        tagging.destroy
      end
    end

    params[:tags].each do |tag|
      if Tagging.find_by(memo_id: @memo.id, tag_id: tag[:id]).nil?
        Tagging.create(memo_id: @memo.id, tag_id: tag[:id])
      end
    end

    @memo.update(title: params[:title], content: params[:content])
    render json: @memo.as_json(include: { tags: { only: [ :id, :name ] } })
  end

  private
  def user_id
    @user_id = User.find()
  end
end
